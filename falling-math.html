<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const gamebox = document.getElementById('gamebox');

  const elScore = document.getElementById('score');
  const elStreak = document.getElementById('streak');
  const elLevel = document.getElementById('level');
  const elMissed = document.getElementById('missed');
  const elHint = document.getElementById('hint');

  const difficultySel = document.getElementById('difficulty');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const input = document.getElementById('answer');
  const overlay = document.getElementById('overlay');

  /* ---------------- Canvas ---------------- */

  function resizeCanvas() {
    const rect = gamebox.getBoundingClientRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    cv.width = Math.floor(rect.width * dpr);
    cv.height = Math.floor(rect.height * dpr);

    cv.style.width = rect.width + 'px';
    cv.style.height = rect.height + 'px';

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  /* ---------------- Game State ---------------- */

  let running = false;
  let paused = false;
  let lastT = 0;

  let score = 0;
  let streak = 0;
  let level = 1;
  let missed = 0;

  let problems = [];
  let spawnTimer = 0;

  const groundY = () =>
    gamebox.getBoundingClientRect().height - 52;

  /* ---------------- Difficulty ---------------- */

  function getDifficulty() {
    const d = difficultySel.value;

    if (d === 'easy')
      return { ops: ['+','-'], maxA: 10, maxB: 10, spawnBase: 1400, speedBase: 55 };

    if (d === 'medium')
      return { ops: ['+','-','×'], maxA: 15, maxB: 12, spawnBase: 1200, speedBase: 70 };

    return { ops: ['+','-','×','÷'], maxA: 20, maxB: 15, spawnBase: 1050, speedBase: 85 };
  }

  /* ---------------- Utils ---------------- */

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function pickOp(ops) {
    return ops[Math.floor(Math.random() * ops.length)];
  }

  /* ---------------- Problems ---------------- */

  function makeProblem() {
    const diff = getDifficulty();
    const op = pickOp(diff.ops);

    let a, b, ans, text;

    if (op === '+') {
      a = randInt(0, diff.maxA);
      b = randInt(0, diff.maxB);
      ans = a + b;
      text = `${a} + ${b}`;
    }

    else if (op === '-') {
      a = randInt(0, diff.maxA);
      b = randInt(0, diff.maxB);

      if (difficultySel.value !== 'hard' && b > a) {
        [a, b] = [b, a];
      }

      ans = a - b;
      text = `${a} − ${b}`;
    }

    else if (op === '×') {
      a = randInt(0, diff.maxA);
      b = randInt(0, diff.maxB);
      ans = a * b;
      text = `${a} × ${b}`;
    }

    else { // division
      b = randInt(1, Math.max(2, diff.maxB));
      const k = randInt(0, Math.max(2, Math.floor(diff.maxA / 2)));

      a = b * k;
      ans = k;
      text = `${a} ÷ ${b}`;
    }

    const rect = gamebox.getBoundingClientRect();

    const x = randInt(
      70,
      Math.max(71, Math.floor(rect.width - 70))
    );

    return {
      id: crypto.randomUUID?.() || String(Math.random()).slice(2),
      text,
      ans,
      x,
      y: -20,
      vy: 0,
      flash: 0,
      state: 'fall'
    };
  }

  function currentSpeed() {
    const diff = getDifficulty();
    const mult = parseFloat(speedControl.value);

    return (diff.speedBase + (level - 1) * 12) * mult;
  }

  function spawnIntervalMs() {
    const diff = getDifficulty();

    return Math.max(
      520,
      diff.spawnBase - (level - 1) * 90
    );
  }

  /* ---------------- HUD ---------------- */

  function updateHUD() {
    elScore.textContent = score;
    elStreak.textContent = streak;
    elLevel.textContent = level;
    elMissed.textContent = missed;

    if (!problems.length) {
      elHint.textContent = 'Waiting for problems…';
      return;
    }

    const lowest = problems.reduce(
      (p, c) => (c.y > p.y ? c : p),
      problems[0]
    );

    elHint.textContent = `Lowest: ${lowest.text}`;
  }

  /* ---------------- Reset / Start ---------------- */

  function resetState() {
    running = false;
    paused = false;
    lastT = 0;

    score = 0;
    streak = 0;
    level = 1;
    missed = 0;

    problems = [];
    spawnTimer = 0;

    input.value = '';

    btnPause.disabled = true;
    btnPause.textContent = 'Pause';

    overlay.style.display = 'grid';

    updateHUD();
    draw();
  }

  function startGame() {
    if (running) return;

    running = true;
    paused = false;

    overlay.style.display = 'none';
    btnPause.disabled = false;
    btnStart.disabled = true;

    input.focus();

    requestAnimationFrame(loop);
  }

  function togglePause() {
    if (!running) return;

    paused = !paused;

    btnPause.textContent = paused ? 'Resume' : 'Pause';

    if (!paused) {
      lastT = 0;
      requestAnimationFrame(loop);
      input.focus();
    }
  }

  function gameOver() {
    running = false;

    btnStart.disabled = false;
    btnPause.disabled = true;

    overlay.style.display = 'grid';

    overlay.querySelector('h1').textContent = 'Game Over';
    overlay.querySelector('p').textContent =
      `Final score: ${score}. Press Start to play again.`;
  }

  /* ---------------- Answer ---------------- */

  function checkAnswer(val) {
    if (!running || paused) return;

    const t = String(val).trim();

    if (!/^-?\d+$/.test(t)) return;

    if (!problems.length) return;

    const guess = Number(t);

    const idx = problems.reduce(
      (b, p, i) => (p.y > problems[b].y ? i : b),
      0
    );

    const target = problems[idx];

    if (guess === target.ans) {

      target.state = 'good';
      target.flash = 1;

      score += 10 + Math.min(25, streak * 2) + Math.floor((level - 1) * 1.5);

      streak++;

      const next = 10 + (level - 1) * 3;

      if (streak % next === 0) level++;

      setTimeout(() => {
        problems = problems.filter(p => p !== target);
        updateHUD();
      }, 120);

    } else {

      target.state = 'bad';
      target.flash = 1;

      streak = 0;
      score = Math.max(0, score - 3);
    }

    input.value = '';
    updateHUD();
  }

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') checkAnswer(input.value);
  });

  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'p') togglePause();

    if (e.key === '/') {
      e.preventDefault();
      input.focus();
    }
  });

  gamebox.addEventListener('pointerdown', () => {
    if (running && !paused) input.focus();
  });

  /* ---------------- Buttons ---------------- */

  btnStart.onclick = startGame;
  btnPause.onclick = togglePause;

  btnReset.onclick = () => {
    btnStart.disabled = false;
    resetState();
  };

  difficultySel.onchange = () => {
    if (running) {
      problems = [];
      spawnTimer = 0;
      updateHUD();
    }
  };

  /* ---------------- Main Loop ---------------- */

  function loop(t) {
    if (!running || paused) return;

    if (!lastT) lastT = t;

    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;

    /* Spawn (FIXED: only once) */
    spawnTimer += dt * 1000;

    while (spawnTimer >= spawnIntervalMs()) {
      spawnTimer -= spawnIntervalMs();
      problems.push(makeProblem());
    }

    /* Update */

    const gY = groundY();
    const speed = currentSpeed();

    for (const p of problems) {

      if (p.state === 'fall') {

        p.vy = speed;
        p.y += p.vy * dt;

        if (p.y >= gY) {
          p.y = gY;
          p.state = 'bad';
          p.flash = 1;

          missed++;
          streak = 0;
        }

      } else {
        p.flash = Math.max(0, p.flash - dt * 3.5);
      }
    }

    problems = problems.filter(
      p => !(p.state === 'bad' && p.y >= gY && p.flash <= 0.01)
    );

    updateHUD();
    draw();

    requestAnimationFrame(loop);
  }

  /* ---------------- Drawing ---------------- */

  function draw() {
    const r = gamebox.getBoundingClientRect();

    const W = r.width;
    const H = r.height;

    ctx.clearRect(0, 0, W, H);

    const gY = groundY();

    ctx.globalAlpha = 0.6;

    ctx.beginPath();
    ctx.moveTo(0, gY + 26);
    ctx.lineTo(W, gY + 26);

    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2;

    ctx.stroke();
    ctx.globalAlpha = 1;

    for (const p of problems) {

      const padX = 14;
      const padY = 10;

      ctx.font = '800 18px system-ui';

      const w = ctx.measureText(p.text).width + padX * 2;
      const h = 44;

      let bg = 'rgba(255,255,255,0.1)';
      let br = 'rgba(255,255,255,0.18)';

      if (p.state === 'good') {
        bg = 'rgba(90,220,140,0.22)';
        br = 'rgba(90,220,140,0.55)';
      }

      if (p.state === 'bad') {
        bg = 'rgba(255,95,95,0.22)';
        br = 'rgba(255,95,95,0.55)';
      }

      const x = Math.min(
        Math.max(p.x - w / 2, 10),
        W - w - 10
      );

      const y = p.y;

      roundRect(ctx, x, y, w, h, 14);

      ctx.fillStyle = bg;
      ctx.fill();

      ctx.strokeStyle = br;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#e9eefc';
      ctx.textBaseline = 'middle';

      ctx.fillText(p.text, x + padX, y + h / 2);
    }
  }

  function roundRect(ctx, x, y, w, h, r) {

    const rr = Math.min(r, w / 2, h / 2);

    ctx.beginPath();

    ctx.moveTo(x + rr, y);

    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);

    ctx.closePath();
  }

  /* ---------------- Init ---------------- */

  resetState();
  btnStart.disabled = false;

})();
</script>

